<!DOCTYPE html>
<html lang="english">
<head>
        <meta charset="utf-8" /> 	
		<meta name="viewport" content="width=device-width">
        <title>Intro to RTL-SDR</title>
        <link rel="stylesheet" href="http://ajoo.blog/theme/css/main.css" />
        <link href="http://ajoo.blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Wintermute Dev Logs Atom Feed" />

        <!--[if IE]>
            <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://ajoo.blog/">Wintermute Dev Logs </a></h1>
                <nav><ul>
<!--                  -->
                    <li><a href="http://ajoo.blog/pages/cv.html"><span class="caps">CV</span></a></li>
                    <li><a href="http://ajoo.blog/pages/about.html">About</a></li>
                    <li><a href="http://ajoo.blog/category/general.html">General</a></li>
                    <li class="active"><a href="http://ajoo.blog/category/sdr.html">SDR</a></li>
                </ul>
                </nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://ajoo.blog/drafts/intro-to-rtl-sdr.html" rel="bookmark"
           title="Permalink to Intro to RTL-SDR">Intro to <span class="caps">RTL</span>-<span class="caps">SDR</span></a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <span>Sun 18 December 2016</span>
<span>| tags: <a href="http://ajoo.blog/tag/rtl-sdr.html">RTL-SDR</a><a href="http://ajoo.blog/tag/python.html">Python</a><a href="http://ajoo.blog/tag/dsp.html">DSP</a></span>
</footer><!-- /.post-info -->      <p><span class="caps">TODO</span>: </p>
<ul>
<li>Intro</li>
<li>Analog Communications 101/<span class="caps">AM</span></li>
<li>Analog Communications 101/<span class="caps">FM</span></li>
<li>Software Defined&nbsp;Radio</li>
<li>A cheap <span class="caps">SDR</span>/innards</li>
<li>The&nbsp;Software/librtlsdr/pyrtlsdr</li>
<li>The Software/librtlsdr/demodulating <span class="caps">FM</span></li>
</ul>
<p>Intro goes&nbsp;here</p>
<h1>Analog Communications&nbsp;101</h1>
<p>Communication systems often involve transmiting a message <span class="math">\(m(t)\)</span> through a pass-band channel, i.e., a channel where only a limited range of frequencies can be used. A good example is comercial <span class="caps">FM</span> radio transmitions, usually restricted to a frequency band between 85 and 108 MHz which must accomodate multiple stations, each one being allocated a &lt;200 kHZ band. Given that the message we&#8217;re interested in transmiting often has support in a different range of frequencies, as is the case of raw audio signals in the human hearing range ([20 Hz; 20 kHz]), the signal must first be shifted in frequency in order to satisfy the requirements of the particular channel of&nbsp;comunication.</p>
<p>This is accomplished by modulation whereby one characteristic of a carrier wave (usually sinusoid like <span class="math">\(A\cos(\omega_c t)\)</span>) will be made to vary according to the <em>modulating signal</em>: <span class="math">\(m(t)\)</span> (also called the message) producing a <em>modulated signal</em>: <span class="math">\(s(t)=B(t)\cos[\omega_c t + \theta (t)]\)</span>. There are two main forms of analog&nbsp;modulation:</p>
<ul>
<li><strong>Amplitude Modulation (<span class="caps">AM</span>)</strong>: where the characteristic that is made to vary is the amplitude <span class="math">\(B(t)\)</span> of the&nbsp;carrier;</li>
<li><strong>Phase/Frequency Modulation (<span class="caps">PM</span>/<span class="caps">FM</span>)</strong>: where the characteristic that varies is the phase <span class="math">\(\theta (t)\)</span> of the&nbsp;carrier.</li>
</ul>
<p><span class="caps">TODO</span>: [<span class="caps">IMAGE</span> <span class="caps">MODULATION</span>]</p>
<p>We&#8217;ll discuss these in the following sections but before we move on here&#8217;s a useful glossary of terms commonly used in&nbsp;telecommunications:</p>
<ul>
<li><strong>Baseband</strong>: the frequency band of the modulating signal, also used to refer to the modulating signal as the baseband&nbsp;signal;</li>
<li><strong>Center frequency</strong>: the frequency around which the spectrum of the modulated signal is&nbsp;centered;</li>
<li><strong>Bandwidth</strong> (of a signal): some measure of the support of a signal in the frequency domain (has many different technical&nbsp;deffinitions).</li>
</ul>
<h1></h1>
<h2>Amplitude&nbsp;Modulation</h2>
<div class="math">$$m(t)e^{i2\pi f_c t}\stackrel{\mathrm{\mathcal{F}}}{\longleftrightarrow}M(f)*\delta(f-f_c)=M(f-f_c)$$</div>
<div class="math">$$m(t)\cos(2\pi f_c t)\stackrel{\mathrm{\mathcal{F}}}{\longleftrightarrow}\frac{1}{2}[M(f-f_c)+M(f+f_c)]$$</div>
<h2>Frequency&nbsp;Modulation</h2>
<h1>Software Defined&nbsp;Radio</h1>
<p>Many forms of radio communication systems were designed with analog technology in mind. Software Defined Radio (<strong><span class="caps">SDR</span></strong>) is a communication system where part of the traditionally analog signal processing, accomplished by means of analog electronic circuits is replaced by digital signal processing, accomplished my means of Analog to Digital Conversion/Digital to Analog Conversion (<span class="caps">ADC</span>/<span class="caps">DCA</span>) and general purpose computers running <span class="caps">DSP</span>&nbsp;software.</p>
<p>By replacing hardware components with software, through inserting an <span class="caps">ADC</span>/<span class="caps">DCA</span> as far upstream the signal flow as possible and processing the digital signal instead, very flexible and general purpose systems can be realized since software is much easier to change than hardware components. Ideally, one would place an <span class="caps">ADC</span> or <span class="caps">DCA</span> directly at the antenna for maximum flexibility  but this is not practical and <span class="caps">SDR</span> systems tipically include a flexible <a href="https://en.wikipedia.org/wiki/RF_front_end"><span class="caps">RF</span> front end</a> before sampling as in the high level diagram below depicting the typical <span class="caps">SDR</span>&nbsp;system:</p>
<p><img alt="Conceptual SDR system" src="http://ajoo.blog/images/SDR_system.svg"></p>
<p>Note that the term Software Defined Radio denotes the whole communication system including the antenna, any specialized hardware and the computer/embedded system running the <span class="caps">DSP</span>. In the following however we&#8217;ll (ab)use it by equating it with the hardware that is used to deliver the digital samples to a personal&nbsp;computer.</p>
<h1>A Cheap <span class="caps">SDR</span></h1>
<p>There are many general purpose commercially available SDRs, both receiver only and transceiver, but they&#8217;re rather expensive in general (&gt;€100 for <span class="caps">RX</span> and &gt;€300 for <span class="caps">RX</span>/<span class="caps">TX</span>). This is where <span class="caps">DVB</span>-T <span class="caps">TV</span> tuner <span class="caps">USB</span> dongles based on the <span class="caps">RTL2832U</span> chipset come into play. As the name indicates, these cheap dongles (~€20) were meant for receiving <span class="caps">DVB</span>-T <span class="caps">TV</span> but hacked drivers from <a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr">Osmocom</a> are able to turn them into wideband receiver only SDRs. This cheap <span class="caps">SDR</span> is therefore tipically known as the <strong><span class="caps">RTL</span>-<span class="caps">SDR</span></strong>:</p>
<p><img alt="RTL dongles" src="http://ajoo.blog/images/RTL_dongles.jpg"></p>
<p>Here you can see the two dongles I own. The one on top is a pretty generic <span class="caps">DVB</span>-T <span class="caps">USB</span> dongle from NooElec. You can see in the picture the remote that comes with it for its intended use as a <span class="caps">TV</span> tuner. It has a standard <span class="caps">MCX</span> antenna connector and comes with a small whip&nbsp;antenna.</p>
<p>The dongle that you see at the bottom is the one sold by the <a href="http://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/"><span class="caps">RTL</span>-<span class="caps">SDR</span> blog</a>. It comes with several improvements over the generic dongles for use as a <span class="caps">SDR</span>. You can read all about these in the the webpage linked. For my intended use of capturing <span class="caps">GPS</span> signals I was mostly interested in the software enabled bias-T in order to power an active <span class="caps">GPS</span> antenna, the <span class="caps">SMA</span> antenna connector and of course the 1 <span class="caps">PPM</span> temperature controlled oscillator for more accurate tuning (the passive cooling is a nice plus too since these units tend to run hot when tuning to frequencies &gt; 1500&nbsp;MHz).</p>
<h2>The innards of <span class="caps">RTL2832U</span> based <span class="caps">DVB</span>-T <span class="caps">TV</span> <span class="caps">USB</span>&nbsp;dongles</h2>
<p>A lot of the information in this section is collected from this <a href="http://superkuh.com/rtlsdr.html">website</a> as well&nbsp;as </p>
<p>Mainly used with three different kinds of tuners, the discontinued (and therefore very hard to find nowadays) Elonics E4000 and the Raphael Micro <span class="caps">R820T</span> and <span class="caps">R820T2</span>. The&nbsp;frequency </p>
<h1>The&nbsp;Software</h1>
<p>In this section I&#8217;ll introduce the software I&#8217;m going to be using for <span class="caps">RTL</span> <span class="caps">SDR</span> projects. To showcase all the tools and make sure the concepts sink in I&#8217;ll be using all of them to  demodulate an <span class="caps">FM</span> signal. I&#8217;ll start with specialized tools that sample the <span class="caps">RTL</span> <span class="caps">SDR</span> and demodulate <span class="caps">FM</span> signals themselves (<strong><span class="caps">SDR</span>#</strong> and <strong>rtl_fm</strong>) and then move on to those that simply capture the <span class="caps">IQ</span> samples from the <span class="caps">RTL</span>-<span class="caps">SDR</span> (<strong>rtl_sdr</strong> and <strong>pyrtlsdr</strong>). Since python will be my language of choice for anything <span class="caps">RTL</span> <span class="caps">SDR</span> related, I&#8217;ll demodulate the <span class="caps">FM</span> signals directly from <span class="caps">IQ</span> samples using only numpy and scipy. I&#8217;m planing to, in a later post, use <span class="caps">GNU</span> radio to do the same in real time as a way to get aqquainted with the&nbsp;software.</p>
<h2><span class="caps">SDR</span>#</h2>
<p>The <span class="caps">RTL</span>-<span class="caps">SDR</span> blog has a great <a href="http://www.rtl-sdr.com/qsg">quickstart guide</a> to get you started with your <span class="caps">RTL</span>-<span class="caps">SDR</span>. If you follow the <span class="caps">SDR</span># Setup Guide section you should be able to get your Osmocom drivers installed and your dongle working with <span class="caps">SDR</span>#. This is a great program with a nice <span class="caps">GUI</span> interface to test your <span class="caps">RTL</span>-<span class="caps">SDR</span> on. It is able to demodulate many different kinds of signals and it gives you a nice visualization of the power spectral density and spectrogram of the output of your <span class="caps">RTL</span> <span class="caps">SDR</span>.</p>
<p>We won&#8217;t play around much with this program so I won&#8217;t elaborate more, but it&#8217;s always nice to have around. Make sure to tune to an <span class="caps">FM</span> radio station you like that has a strong enough signal and write down its frequency. I will be using 97.4 MHz throughout this post, the frequency for Radio Comercial here in Lisbon, which has a particularly strong signal where I&#8217;m&nbsp;living.</p>
<h2>librtlsdr and the Command Line&nbsp;tools</h2>
<p>Pretty much all software that interfaces with the <span class="caps">RTL</span>-<span class="caps">SDR</span> makes use of this library. If you followed the quickstart guide linked above and downloaded <span class="caps">SDR</span>#, one of the things it has you do is run a batch file that downloads this library and copies the 32 bit version of rtlsdr.dll to the sdrsharp folder. Sadly it throws the rest of it away so you&#8217;ll have to go ahead to the <a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr">Osmocom rtl-sdr wiki</a> and download it again if you need the 64 bit version and the command line utilities that come packaged with it. You can either build it from <a href="http://cgit.osmocom.org/rtl-sdr">source</a> or grab the <a href="http://sdr.osmocom.org/trac/attachment/wiki/rtl-sdr/RelWithDebInfo.zip">pre-built windows version</a>.</p>
<p>In it&#8217;s 32 and 64 bits releases librtlsdr contains a number of command line utilities and 3 dlls. Of the command line tools we&#8217;ll be mostly interested in <strong>rtl_test</strong>, <strong>rtl_sdr</strong> and <strong>rtl_fm</strong> for now. The dynamic-link library rtlsdr.dll is what contains the functions to interface with <span class="caps">RTL</span> <span class="caps">SDR</span> that are used by all other&nbsp;tools.</p>
<h3>rtl_test</h3>
<p>We&#8217;ll start our exploration of librtlsdr with rtl_test. This is a command line utility that allows you to perform different tests on your <span class="caps">RTL</span> <span class="caps">SDR</span> dongle and figure out the allowable ranges for some of the control parameters when capturing samples with your dongle. The following command will capture samples at 2.4 MHz and report any samples lost. You can suspend the program with Ctrl+C and it will tell you how many samples per million were&nbsp;lost:</p>
<div class="highlight"><pre><span></span>&gt; rtl_test -s 2400000
Found 1 device(s):
  0:  Realtek, RTL2838UHIDIR, SN: 00000001

Using device 0: Generic RTL2832U OEM
Found Rafael Micro R820T tuner
Supported gain values (29): 0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7
 20.7 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0
 49.6
Sampling at 2400000 S/s.

Info: This tool will continuously read from the device, and report if
samples get lost. If you observe no further output, everything is fine.

Reading samples in async mode...
lost at least 64 bytes
lost at least 144 bytes
lost at least 100 bytes
Signal caught, exiting!

User cancel, exiting...
Samples per million lost (minimum): 3
</pre></div>


<p>As you can see it will also report all the supported values for the gain setting of the tuner. When you specify a tuner gain in any other program it will usually use the nearest allowable value. Keep in mind that the default when no gain is specified is usually to use automatic gain control which uses a feedback of the signal itself to control the gain of the input <span class="caps">LNA</span>.</p>
<p>As you can see my <span class="caps">RTL</span>-<span class="caps">SDR</span> blog dongle is dropping a few samples at 2.4 MHz. You can try different settings of the sample rate with the <strong>-s</strong> option in order to figure out a safe sample rate at which no samples are dropped. Keep in mind that this can vary according to temperature and also your computer and <span class="caps">USB</span>&nbsp;ports. </p>
<p>The allowed range of sample rates for <span class="caps">RTL</span> <span class="caps">SDR</span> dongles is [225001; 300000] ∪ [900001; 3200000] Hz. If you try to use a sample rate outside of this range you will get an &#8220;Invalid sample rate&#8221; message and the default of 2.048 MHz will be used by&nbsp;rtl_test.</p>
<p>Using the <strong>-p</strong> option will also report the <span class="caps">PPM</span> error measurement as estimated (I think) from measuring <span class="caps">GSM</span> signals (since they&#8217;re quite high frequency). Letting it run for a few minutes should give you a somewhat reliable estimate that you can then use as the frequency correction parameter for other programs such as <span class="caps">SDR</span># or rtl_sdr. Unfortunately, I couldn&#8217;t get this to work myself as I get no <span class="caps">PPM</span> reports from running the program and I&#8217;m not sure&nbsp;why&#8230;</p>
<h3>rtl_fm</h3>
<p>rtl_fm is a very resource efficient command line tool to capture <span class="caps">IQ</span> samples from the <span class="caps">RTL</span> <span class="caps">SDR</span> and demodulate <span class="caps">FM</span>, <span class="caps">AM</span> and <span class="caps">SSB</span> signals. For more information on this program make sure to check the <a href="http://kmkeen.com/rtl-demod-guide/">rtl_fm guide</a>.</p>
<p>The following command will demodulate and record a wideband <span class="caps">FM</span> channel at 97.4 MHz and record it in a file output.raw. You can press Ctrl+C to exit after capturing enough&nbsp;samples.</p>
<div class="highlight"><pre><span></span>&gt; rtl_fm -M wbfm -f 97.4M -g 20 output.raw
</pre></div>


<p>The meaning of the options&nbsp;is:</p>
<ul>
<li><strong>-M wbfm</strong>: wideband <span class="caps">FM</span>&nbsp;modulation;</li>
<li><strong>-f 97.4M</strong>: center frequency of 97.4&nbsp;MHz;</li>
<li><strong>-g 20</strong>: sets the tuner gain to the closest allowable value to 20 dB (19.7 dB). Without this option present automatic gain is&nbsp;used.</li>
</ul>
<p>when using -M wbfm a few implicit options are assumed (which can be explicitely&nbsp;overriden):</p>
<ul>
<li><strong>-s 170k</strong>: for wideband <span class="caps">FM</span> a sample rate of 170 kHz is chosen by&nbsp;default;</li>
<li><strong>-A fast</strong>: fast polynomial approximation of arctangent used in&nbsp;demodulation;</li>
<li><strong>-r 32k</strong>: output is decimated to 32&nbsp;kHz;</li>
<li><strong>-l 0</strong>: disables&nbsp;squelch;</li>
<li><strong>-E deemp</strong>: applies a deemphesis&nbsp;filter.</li>
</ul>
<p>The output I get running this command and then stopping the execution after a few seconds&nbsp;is:</p>
<div class="highlight"><pre><span></span>Found 1 device(s):
  0:  Realtek, RTL2838UHIDIR, SN: 00000001

Using device 0: Generic RTL2832U OEM
Found Rafael Micro R820T tuner
Tuner gain set to 19.70 dB.
Tuned to 97671000 Hz.
Oversampling input by: 6x.
Oversampling output by: 1x.
Buffer size: 8.03ms
Exact sample rate is: 1020000.026345 Hz
Sampling at 1020000 S/s.
Output at 170000 Hz.
Signal caught, exiting!
</pre></div>


<p>You might notice that rtl_fm tuned to a different frequency (97.671 MHz) than that we specified (97.4 MHz). This is done to avoid a known imperfection in <span class="caps">RTL</span>-SDRs that causes a small <span class="caps">DC</span> bias to be present at the <span class="caps">ADC</span> output. This way the dongle is tuned to a slightly different frequency to avoid the <span class="caps">DC</span> spike and the software later corrects for this in the digital signal processing by shifting the captured signal in frequency to 0&nbsp;Hz.</p>
<p>Notice also that the software oversamples by 6x at 1.02 MHz and then decimates the output to the (implicitely) specified frequency of 170 kHz before demodulating. This is because, first and foremost, 170 kHz is not a valid sampling frequency for the <span class="caps">RTL</span>-<span class="caps">SDR</span> (see the rtl_test section above for the valid range). 1.02 MHz is in fact the first integer multiple of 170 kHz that fits in the allowed range. But this is not the only reason; in fact if we specifically ask rtl_fm to sample the input at 240 kHZ with <strong>-s 240k</strong>, it will still oversample by 5x at 1.2 MHz despite the fact that 240 MHz is within the allowed range of sampling frequencies of the <span class="caps">RTL</span> <span class="caps">SDR</span>:</p>
<div class="highlight"><pre><span></span>Oversampling input by: 5x.
Oversampling output by: 1x.
Buffer size: 6.83ms
Sampling at 1200000 S/s.
Output at 240000 Hz.
</pre></div>


<p>My assumption is that this is done in order to mitigate the quantization noise. Recall that the output of the <span class="caps">RTL</span> <span class="caps">SDR</span> is 8 bits and therefore oversampling and decimating in software where we&#8217;re not limited to 8 bits should provide a better noise figure than relying on doing the decimation in the chip. Furthermore, it provides greater control over the decimation process, letting the software choose the low-pass filter. From these considerations it would make sense to always use the highest possible sampling rate but rtl_fm is built with limited resources in mind so that might provide a reason for it compromising for sampling frequencies closer to 1&nbsp;MHz.</p>
<p>rtl_fm stores the raw audio in a file as signed 16 bits integers. To load it in python with numpy you can therefore&nbsp;do:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">raw_audio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="s2">&quot;output.raw&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
</pre></div>


<p>To listen to it you can always use scipy to store it as a .wav file and then play it in your favourite media&nbsp;player:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.io</span> <span class="kn">import</span> <span class="n">wavfile</span>

<span class="n">wavfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;COMERCIAL.wav&quot;</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">32000</span><span class="p">,</span> <span class="n">raw_audio</span><span class="p">)</span>
</pre></div>


<p>Recall that the default output rate of rtl_fm in wideband <span class="caps">FM</span> mode is 32 kHz but if you changed that with the -r option make sure to provide wavfile.write with the correct one (and that it is within the range of your sound&nbsp;card&#8230;).</p>
<p>Alternativelly you could install and use <a href="http://sox.sourceforge.net/">SoX</a> which is a great program to convert audio files between formats (including raw audio signals), as well as playing and recording them. The following command will play the raw audio file with sample rate 32 kHz, 16 bits signed int encoding and 1&nbsp;channel:</p>
<div class="highlight"><pre><span></span>&gt; sox -r 32k -t raw -e signed -b 16 -c 1 COMERCIAL.RAW -t waveaudio
</pre></div>


<p>You can replace &#8220;-t waveaudio&#8221; with a .wav filename to store it in a wav file instead. Make sure to refer to <a href="http://sox.sourceforge.net/sox.html">SoX&#8217;s documentation</a> for a full description of the options&nbsp;available.</p>
<h3>rtl_sdr</h3>
<p>Finally, the most general use command line tool in the librtlsdr package is rtl_sdr. This program will let you capture <span class="caps">IQ</span> samples directly and store them in a&nbsp;file:</p>
<div class="highlight"><pre><span></span>&gt; rtl_sdr -f 97400000 -g 20 -s 1020000 -n 10200000 COMERCIAL_s1m02_g20.bin
</pre></div>


<p>The options in this case&nbsp;mean:</p>
<ul>
<li><strong>-f 97400000</strong>: sets the tuner frequency to 97.4&nbsp;MHz;</li>
<li><strong>-g 20</strong>: sets the tuner gain to the closest allowable value to 20 dB (19.7&nbsp;dB);</li>
<li><strong>-s 1020000</strong>: sets the sample rate to 1.02&nbsp;MHz;</li>
<li><strong>-n 10200000</strong>: instructs rtl_sdr to capture 1.02e7 samples which should amount to a 10 seconds worth of samples at the given sample rate (10 s * 1.02e6&nbsp;MHz).</li>
</ul>
<p>This utility stores the I and Q samples alternately as 8 bits unsigned integers. In order to load them in python we can therefore use something&nbsp;like:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">load_iq</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="o">-</span><span class="mi">127</span><span class="p">)</span> <span class="c1">#adding a signed int8 to an unsigned one results in an int16 array</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>    <span class="c1">#we cast it back to an int8 array and reshape</span>
</pre></div>


<p>This will load the file and return an numpy.int8 numpy array with shape (nsamples, 2), the first column corresponding to I samples and the second to Q&nbsp;samples.</p>
<p>A more convenient format to process the data digitally is to load it as complex samples (I + j*Q). Unfortunately numpy doesn&#8217;t have a complex integer type so we&#8217;ll have to incur in a bit of memory overhead and spring for a numpy.complex64 array which makes it less useful when dealing with a large number of&nbsp;samples:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_iq_complex</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">127.5</span><span class="p">)</span> <span class="c1">#by subtracting a float32 the resulting array will also be float32</span>
    <span class="k">return</span> <span class="mf">8e-3</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>                        <span class="c1">#viewing it as a complex64 array then yields the correct result</span>
</pre></div>


<h2></h2>
<h2>pyrtlsdr</h2>
<p>pyrtlsdr is a python library that wraps the librtlsdr rtlsdr.dll functions. It lets you read <span class="caps">IQ</span> samples from your <span class="caps">RTL</span> <span class="caps">SDR</span> directly in python and get them into a complex numpy&nbsp;array.</p>
<p>You should make sure that the librtlsdr dlls can be found by pyrtlsdr. Either add them to your python path or just drop a copy in your working directory&#8230;
To collect 10 seconds of data with the same characteristics as that we collected with rtl_sdr we would&nbsp;do:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">rtlsdr</span> <span class="kn">import</span> <span class="n">RtlSdr</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">closing</span>

<span class="c1">#we use a context manager that automatically calls .close() on sdr</span>
<span class="c1">#whether the code block finishes successfully or an error occurs</span>
<span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">RtlSdr</span><span class="p">())</span> <span class="k">as</span> <span class="n">sdr</span><span class="p">:</span>  
    <span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">1020000</span>
    <span class="n">sdr</span><span class="o">.</span><span class="n">center_freq</span> <span class="o">=</span> <span class="mf">97.4e6</span>
    <span class="n">sdr</span><span class="o">.</span><span class="n">gain</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="c1">#sdr.freq_correction = </span>
    <span class="c1">#sdr.bandwidth = </span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sdr</span><span class="o">.</span><span class="n">read_samples</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">sdr</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
</pre></div>


<p>Other properties of the RtlSdr class&nbsp;are:</p>
<ul>
<li>freq_correction</li>
<li>bandwidth</li>
</ul>
<h1>Demodulating <span class="caps">FM</span></h1>
<p>Now that we know how to capture <span class="caps">IQ</span> samples and load them in python, either through rtl_sdr or the pyrtlsdr python library, we can work on getting from these <span class="caps">IQ</span> samples to an actual audible&nbsp;signal.</p>
<p>Basics of <span class="caps">FM</span>&nbsp;modulation</p>
<p><a href="http://www.embedded.com/design/configurable-systems/4212086/DSP-Tricks--Frequency-demodulation-algorithms-"><span class="caps">DSP</span>&nbsp;Tricks</a></p>
<h1>Up&nbsp;Next</h1>
<p>My next posts will be an introduction to <span class="caps">GNU</span> radio where I&#8217;ll demodulate <span class="caps">FM</span> signals in real time and another which will provide a brief overview to the <span class="caps">GPS</span> system and sampling of <span class="caps">GPS</span> L1 signals. Stay&nbsp;tuned!</p>
<h1>Useful&nbsp;Links:</h1>
<ul>
<li><a href="http://www.rtl-sdr.com/">rtl-sdr</a></li>
<li><a href="http://sdr.osmocom.org/trac/wiki/rtl-sdr">Osmocom rtl-sdr&nbsp;wiki</a></li>
<li><a href="https://www.reddit.com/r/RTLSDR/"><span class="caps">RTL</span>-<span class="caps">SDR</span> subreddit</a> A subreddit dedicated to <span class="caps">RTL</span>-<span class="caps">SDR</span>. Make sure to check their wiki which is filled with useful&nbsp;information.</li>
<li><a href="http://rtlsdr.org/">rtlsdr Community&nbsp;Wiki</a></li>
<li><a href="http://superkuh.com/rtlsdr.html">superkuh&#8217;s website</a> An absolute bible when it comes to the internals of <span class="caps">RTL</span>-<span class="caps">SDR</span> <span class="caps">USB</span> dongles. Tons of useful information, links to datasheets, schematics,&nbsp;etc&#8230; </li>
</ul>
<h1>Educational&nbsp;Links:</h1>
<ul>
<li><a href="http://www.eas.uccs.edu/~mwickert/ece4670/">University of Colorado&#8217;s Communications Lab</a> Make sure to check out their lab assignments, particularly Lab 6 which this blog post draws inspiration&nbsp;from;</li>
<li><a href="http://web.stanford.edu/class/ee179/">Stanford&#8217;s Analog and Digital Communication Systems 2014 course</a> Again, make sure to check out the lab assignments with lots of <span class="caps">RTL</span>-<span class="caps">SDR</span>&nbsp;materials;</li>
</ul>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>blogroll</h2>
                        <ul>
                            <li><a href="mailto:ajoo@outlook.pt">email</a></li>
                            <li><a href="https://www.kaggle.com/ajoo88">kaggle</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="http://ajoo.blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                            <li><a href="https://github.com/Ajoo">github</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme <a href="https://github.com/blueicefield/pelican-blueidea/">blueidea</a>, inspired by the default theme.</p>
        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-89270740-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'ajoo-blog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>